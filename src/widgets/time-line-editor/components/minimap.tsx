"use client";

import { useRef, useEffect, useState } from "react";
import * as d3 from "d3";
import { X, Maximize2 } from "lucide-react";
import { TimeColumn } from "../lib/timeline-utils";
import { TimelineEvent } from "../types/timeline-editor-types";
import { Button } from "@/shared/ui/button";

interface MinimapProps {
  timeColumns: TimeColumn[];
  events: TimelineEvent[];
  panTransform: { x: number; y: number };
  onPanChange: (transform: { x: number; y: number }) => void;
  columnWidth: number;
  viewportDimensions: { width: number; height: number };
  onClose: () => void;
}

export function Minimap({
  timeColumns,
  events,
  panTransform,
  onPanChange,
  columnWidth,
  viewportDimensions,
  onClose,
}: MinimapProps) {
  const svgRef = useRef<SVGSVGElement>(null);
  const [isExpanded, setIsExpanded] = useState(false);

  // ÎØ∏ÎãàÎßµ ÌÅ¨Í∏∞ ÏÑ§Ï†ï
  const minimapWidth = isExpanded ? 400 : 200;
  const minimapHeight = isExpanded ? 300 : 150;
  const margin = { top: 10, right: 10, bottom: 10, left: 10 };

  useEffect(() => {
    if (!svgRef.current || timeColumns.length === 0) return;

    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove();

    // Ï†ÑÏ≤¥ ÌÉÄÏûÑÎùºÏù∏ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞ (Ïã§Ï†ú Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ÏôÄ ÎèôÏùºÌïòÍ≤å)
    const totalTimelineWidth = timeColumns.length * columnWidth;
    const totalTimelineHeight = 800; // ÏÑ∏Î°ú ÏòÅÏó≠ ÌÅ¨Í∏∞

    // Ïã§Ï†ú Î∑∞Ìè¨Ìä∏ ÌÅ¨Í∏∞ (ÎßàÏßÑ Ï†úÏô∏)
    const actualViewportWidth = viewportDimensions.width - 240; // Ï¢åÏö∞ ÎßàÏßÑ 120Ïî©
    const actualViewportHeight = viewportDimensions.height - 110; // ÏÉÅÌïò ÎßàÏßÑ (Ìó§Îçî 80 + Ïó¨Î∞±)

    // Ïä§ÏºÄÏùº Í≥ÑÏÇ∞
    const scaleX =
      (minimapWidth - margin.left - margin.right) / totalTimelineWidth;
    const scaleY =
      (minimapHeight - margin.top - margin.bottom) / totalTimelineHeight;

    const g = svg
      .append("g")
      .attr("transform", `translate(${margin.left}, ${margin.top})`);

    // Î∞∞Í≤Ω
    const background = g
      .append("rect")
      .attr("width", minimapWidth - margin.left - margin.right)
      .attr("height", minimapHeight - margin.top - margin.bottom)
      .attr("fill", "#f9fafb")
      .attr("stroke", "#e5e7eb")
      .attr("stroke-width", 1)
      .style("cursor", "crosshair");

    // ÌÉÄÏûÑÎùºÏù∏ Ïª¨Îüº ÌëúÏãú (ÏÑ∏Î°úÏÑ†)
    timeColumns.forEach((column, i) => {
      const x = i * columnWidth * scaleX;
      g.append("line")
        .attr("x1", x)
        .attr("x2", x)
        .attr("y1", 0)
        .attr("y2", minimapHeight - margin.top - margin.bottom)
        .attr("stroke", "#d1d5db")
        .attr("stroke-width", 0.5);
    });

    // Ïù¥Î≤§Ìä∏ ÌëúÏãú (ÏûëÏùÄ Ïõê)
    events.forEach((event) => {
      const x = event.x * scaleX;
      const y = event.y * scaleY;

      g.append("circle")
        .attr("cx", x)
        .attr("cy", y)
        .attr("r", isExpanded ? 3 : 2)
        .attr("fill", event.color)
        .attr("stroke", "white")
        .attr("stroke-width", 0.5)
        .style("cursor", "pointer")
        .on("click", (clickEvent) => {
          clickEvent.stopPropagation();
          // Ïù¥Î≤§Ìä∏ ÌÅ¥Î¶≠ Ïãú Ìï¥Îãπ ÏúÑÏπòÎ°ú Ïù¥Îèô
          const centerX = actualViewportWidth / 2;
          const centerY = actualViewportHeight / 2;
          const newPanX = centerX - event.x;
          const newPanY = centerY - event.y;

          // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
          const minX = Math.min(0, -(totalTimelineWidth - actualViewportWidth));
          const maxX = 0;
          const minY = Math.min(
            0,
            -(totalTimelineHeight - actualViewportHeight)
          );
          const maxY = 0;

          const boundedX = Math.max(minX, Math.min(maxX, newPanX));
          const boundedY = Math.max(minY, Math.min(maxY, newPanY));

          onPanChange({ x: boundedX, y: boundedY });
        });

      // Ïù¥Î≤§Ìä∏ Ï†úÎ™© ÌëúÏãú (ÌôïÏû• Î™®ÎìúÏóêÏÑúÎßå)
      if (isExpanded) {
        g.append("text")
          .attr("x", x + 5)
          .attr("y", y + 1)
          .attr("class", "text-xs fill-gray-700")
          .attr("font-size", "8px")
          .text(
            event.title.length > 10
              ? event.title.substring(0, 10) + "..."
              : event.title
          )
          .style("pointer-events", "none");
      }
    });

    // ÌòÑÏû¨ Î∑∞Ìè¨Ìä∏ ÏòÅÏó≠ ÌëúÏãú (ÏàòÏ†ïÎêú Í≥ÑÏÇ∞)
    const viewportWidth = actualViewportWidth * scaleX;
    const viewportHeight = actualViewportHeight * scaleY;

    // Î∑∞Ìè¨Ìä∏ ÏúÑÏπò Í≥ÑÏÇ∞ (pan transformÏùÑ Î∞òÏòÅ)
    const viewportX = Math.max(0, -panTransform.x * scaleX);
    const viewportY = Math.max(0, -panTransform.y * scaleY);

    // Î∑∞Ìè¨Ìä∏Í∞Ä ÎØ∏ÎãàÎßµ Í≤ΩÍ≥ÑÎ•º Î≤óÏñ¥ÎÇòÏßÄ ÏïäÎèÑÎ°ù ÌÅ¥Îû®Ìïë
    const maxViewportX =
      minimapWidth - margin.left - margin.right - viewportWidth;
    const maxViewportY =
      minimapHeight - margin.top - margin.bottom - viewportHeight;

    const clampedViewportX = Math.max(0, Math.min(maxViewportX, viewportX));
    const clampedViewportY = Math.max(0, Math.min(maxViewportY, viewportY));

    // Î∑∞Ìè¨Ìä∏ ÌÅ¨Í∏∞ÎèÑ Í≤ΩÍ≥ÑÏóê ÎßûÍ≤å Ï°∞Ï†ï
    const clampedViewportWidth = Math.min(
      viewportWidth,
      minimapWidth - margin.left - margin.right - clampedViewportX
    );
    const clampedViewportHeight = Math.min(
      viewportHeight,
      minimapHeight - margin.top - margin.bottom - clampedViewportY
    );

    const viewport = g
      .append("rect")
      .attr("x", clampedViewportX)
      .attr("y", clampedViewportY)
      .attr("width", Math.max(0, clampedViewportWidth))
      .attr("height", Math.max(0, clampedViewportHeight))
      .attr("fill", "rgba(59, 130, 246, 0.2)")
      .attr("stroke", "#3b82f6")
      .attr("stroke-width", 2)
      .style("cursor", "move");

    // Ï¢åÌëú Î≥ÄÌôò Ìï®ÏàòÎì§ÏùÑ Î®ºÏ†Ä Ï†ïÏùò
    const minimapToWorld = (minimapX: number, minimapY: number) => {
      const worldX = minimapX / scaleX;
      const worldY = minimapY / scaleY;
      return { x: worldX, y: worldY };
    };

    const worldToPan = (worldX: number, worldY: number) => {
      const centerX = actualViewportWidth / 2;
      const centerY = actualViewportHeight / 2;
      const newPanX = centerX - worldX;
      const newPanY = centerY - worldY;

      // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
      const minX = Math.min(0, -(totalTimelineWidth - actualViewportWidth));
      const maxX = 0;
      const minY = Math.min(0, -(totalTimelineHeight - actualViewportHeight));
      const maxY = 0;

      const boundedX = Math.max(minX, Math.min(maxX, newPanX));
      const boundedY = Math.max(minY, Math.min(maxY, newPanY));

      return { x: boundedX, y: boundedY };
    };

    // Î∞∞Í≤Ω ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ (Îã®Ïàú ÌÅ¥Î¶≠Îßå)
    background.on("click", (event) => {
      const [mouseX, mouseY] = d3.pointer(event, g.node());
      const world = minimapToWorld(mouseX, mouseY);
      const newPan = worldToPan(world.x, world.y);
      onPanChange(newPan);
    });

    // Î∑∞Ìè¨Ìä∏ ÎìúÎûòÍ∑∏ Í∏∞Îä• (Îã®ÏàúÌôî)
    let isDragging = false;

    viewport.style("cursor", "move").on("mousedown", (event) => {
      event.preventDefault();
      event.stopPropagation();
      isDragging = true;

      const handleMouseMove = (moveEvent: MouseEvent) => {
        if (!isDragging) return;

        const rect = svgRef.current?.getBoundingClientRect();
        if (!rect) return;

        const mouseX = moveEvent.clientX - rect.left - margin.left;
        const mouseY = moveEvent.clientY - rect.top - margin.top;

        const world = minimapToWorld(mouseX, mouseY);
        const newPan = worldToPan(world.x, world.y);
        onPanChange(newPan);
      };

      const handleMouseUp = () => {
        isDragging = false;
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    });

    console.log("üó∫Ô∏è Minimap updated:", {
      panTransform,
      viewportDimensions,
      actualViewportWidth,
      actualViewportHeight,
      viewportX: clampedViewportX,
      viewportY: clampedViewportY,
      viewportWidth: clampedViewportWidth,
      viewportHeight: clampedViewportHeight,
      scaleX,
      scaleY,
    });
  }, [
    timeColumns,
    events,
    panTransform,
    columnWidth,
    viewportDimensions,
    onPanChange,
    minimapWidth,
    minimapHeight,
    isExpanded,
  ]);

  return (
    <div className="fixed bottom-6 left-6 z-50 bg-white rounded-lg shadow-xl border border-gray-200 overflow-hidden">
      {/* Ìó§Îçî */}
      <div className="flex items-center justify-between p-2 bg-gray-50 border-b border-gray-200">
        <div className="flex items-center gap-2">
          <div className="w-2 h-2 bg-blue-500 rounded-full"></div>
          <span className="text-xs font-medium text-gray-700">ÎØ∏ÎãàÎßµ</span>
        </div>
        <div className="flex items-center gap-1">
          <Button
            variant="ghost"
            size="icon"
            className="h-6 w-6"
            onClick={() => setIsExpanded(!isExpanded)}
            title={isExpanded ? "Ï∂ïÏÜå" : "ÌôïÎåÄ"}
          >
            <Maximize2 className="h-3 w-3" />
          </Button>
          <Button
            variant="ghost"
            size="icon"
            className="h-6 w-6"
            onClick={onClose}
            title="Îã´Í∏∞"
          >
            <X className="h-3 w-3" />
          </Button>
        </div>
      </div>

      {/* ÎØ∏ÎãàÎßµ SVG */}
      <div className="relative">
        <svg
          ref={svgRef}
          width={minimapWidth}
          height={minimapHeight}
          className="block"
        />

        {/* Î≤îÎ°Ä */}
        <div className="absolute bottom-2 left-2 bg-white bg-opacity-90 rounded px-2 py-1 text-xs text-gray-600">
          <div className="flex items-center gap-4">
            <div className="flex items-center gap-1">
              <div className="w-2 h-2 bg-blue-500 rounded-full opacity-20"></div>
              <span>Î∑∞Ìè¨Ìä∏</span>
            </div>
            <div className="flex items-center gap-1">
              <div className="w-2 h-2 bg-gray-400 rounded-full"></div>
              <span>Ïù¥Î≤§Ìä∏</span>
            </div>
          </div>
        </div>

        {/* ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥ (ÌôïÏû• Î™®ÎìúÏóêÏÑúÎßå) */}
        {isExpanded && (
          <div className="absolute top-2 right-2 bg-white bg-opacity-90 rounded px-2 py-1 text-xs text-gray-600 font-mono">
            <div>Pan X: {Math.round(panTransform.x)}</div>
            <div>Pan Y: {Math.round(panTransform.y)}</div>
            <div>
              Viewport: {viewportDimensions.width}√ó{viewportDimensions.height}
            </div>
            <div>Events: {events.length}</div>
            <div>Columns: {timeColumns.length}</div>
          </div>
        )}
      </div>
    </div>
  );
}
